### **模块一：玩家角色创建与基础移动**

**1. 目标**
创建一个可由玩家控制的基础角色，并实现其在二维空间内的响应式移动。此模块是后续所有交互玩法的基础。

**2. 任务清单**

**2.1. 任务：创建玩家场景 (`Player Scene`)**

- **描述**: 创建一个独立的、可复用的玩家场景文件。
- **规格**:
    - **根节点类型**: `CharacterBody2D`。
        - *理由*: 使用 Godot 引擎推荐的物理角色节点，以方便地使用其内置的 `move_and_slide` 等移动和碰撞处理功能。
    - **子节点 1 - 物理形状**: `CollisionShape2D`。
        - *理由*: 为角色定义物理边界，用于碰撞检测。形状可暂定为胶囊体或矩形。
    - **子节点 2 - 视觉呈现**: `Sprite2D`。
        - *理由*: 显示角色的图像。在初期阶段，可使用任意占位符图片。
- **产出**: `scenes/player/player.tscn` 文件。

**2.2. 任务：实现移动逻辑 (`Movement Script`)**

- **描述**: 编写脚本，处理用户输入并将其转化为角色的移动。
- **规格**:
    - **脚本位置**: 附加在 `Player Scene` 的根节点上。
    - **核心逻辑**:
        1. **定义一个可配置的移动速度变量**，方便后期在编辑器中直接调整数值。
        2. **在物理更新函数 (`_physics_process`) 中**：
            - 获取玩家的**持续性方向输入**（如：WASD或方向键）。
            - 根据输入的方向和移动速度变量，计算出角色的**目标速度向量**。
            - 调用 `CharacterBody2D` 的内置方法（`move_and_slide`）来**执行位移**，确保移动过程能正确响应物理碰撞。
- **产出**: `scripts/player/player.gd` 文件。

### **模块二：动态与多主题竞技场 (Dynamic & Multi-Theme Arena)**

**1. 目标**

构建一个功能完备的游戏竞技场。该竞技场需具备程序化生成、边界动态调整的能力，并能轻松支持多种不同的美术主题（如森林、洋馆），为核心战斗提供一个清晰、可靠且富有变化的场地。

**2. 核心方案：混合实现**

我们将采用“**TileMap为骨架，精灵为血肉**”的混合方案，兼顾程序化控制的便利性与美术表现的自由度。

- **骨架 (TileMap)**: 用于高效铺设地面、构建**不可见的物理边界**。
- **血肉 (精灵拼装)**: 用于在场景中添加装饰性物件，打破网格的单调感，体现不同主题的特色。

**3. 任务清单**

**3.1. 任务：数据结构 - 定义“主题资源”**

- **描述**: 创建一个自定义的`Resource`脚本，用于将构成一个场景主题的所有元素打包管理。
- **规格**:
    - 脚本命名为 `arena_theme.gd` (`ArenaThemeResource`)。
    - 该资源需包含以下可配置字段：
        - `主题名称 (theme_name)`: 字符串。
        - `瓦片图集 (tileset)`: `TileSet` 资源。这是主题的核心，定义了地板和墙壁的视觉样式。
        - `背景音乐 (background_music)`: `AudioStream` 资源。
        - （可选）`装饰物精灵列表 (decoration_sprites)`: 一个包含多个 `Texture2D` 或 `PackedScene` 的数组，用于程序化散布。
- **产出**: `scripts/resources/arena_theme.gd` 脚本文件。

**3.2. 任务：美术资源 - 创建基础主题**

- **描述**: 至少创建两套不同风格的`TileSet`美术图集，用于验证主题切换功能。
- **规格**:
    - **主题一 (例如：默认)**: 包含基础的地板图块和一个用于墙壁的图块（此图块可为透明，仅用于附加碰撞体）。
    - **主题二 (例如：森林)**: 包含草地/泥土图块作为地板，以及对应的墙壁图块。
    - 在Godot编辑器内，根据上述图集创建对应的`TileSet`资源，并**务必为墙壁图块配置好物理碰撞形状**。
- **产出**: 至少两份美术图集文件和对应的Godot `TileSet`资源文件。

**3.3. 任务：场景构建 (`Arena Scene`)**

- **描述**: 搭建竞技场的核心场景。
- **规格**:
    - **根节点**: `Node2D`，命名为 `Arena`。
    - **子节点 1 - 核心层**: `TileMap` 节点，用于承载地板和物理边界。
    - **子节点 2 - 装饰层**: `Node2D` 节点，命名为 `Decorations`，作为所有装饰性精灵的容器，方便管理。
    - **子节点 3 - 音频**: `AudioStreamPlayer` 节点，用于播放主题音乐。
    - 将一个核心脚本 `arena.gd` 附加到 `Arena` 根节点上。
- **产出**: `scenes/levels/arena.tscn` 场景文件和 `scripts/systems/arena.gd` 脚本文件。

**3.4. 任务：实现核心逻辑 (`Arena Script`)**

- **描述**: 编写`arena.gd`脚本，赋予竞技场生命。
- **规格**:
    - **功能1 - 主题加载**: 实现一个函数 `load_theme(theme_resource)`，它会接收一个 `ArenaThemeResource`，然后将该资源内的 `TileSet` 和 `AudioStream` 分别应用到场景中的`TileMap`和`AudioStreamPlayer`节点上。
    - **功能2 - 场地生成**: 实现一个函数 `generate_arena(width, height)`，它会：
        1. 清空当前的`TileMap`。
        2. 根据传入的宽高，遍历所有坐标。
        3. 在边界坐标上，放置带有碰撞体的“墙壁”图块。
        4. 在内部坐标上，放置“地板”图块。

**4. 验收标准**

- 游戏启动后，可以通过代码调用 `generate_arena` 函数，程序化地创建一个具有指定尺寸的矩形竞技场。
- 玩家角色（模块一产出）被放置在竞技场中时，其行动范围被不可见的墙壁正确限制，无法离开场地。
- 通过调用 `load_theme` 函数并传入不同的“主题资源”，竞技场**地板的视觉样式和背景音乐**会立刻随之改变，但物理边界和场地形状保持不变。
- （可选）场景中出现了与当前主题相符的装饰性精灵。

### **模块三：敌人生成系统 (附带编辑器拓展)**

**1. 目标**
建立一个完整、高效、且直观的敌人生成工作流。此模块分为两个主要部分：

- **后端**: 一个能在运行时精确执行波次生成逻辑的系统。
- **前端**: 一个在Godot编辑器内，能让设计师通过可视化时间轴来直观地创建和编辑波次的自定义工具。

**2. 核心数据结构 (再次确认)**
此模块所有工作都将围绕我们之前设计的、解耦的Resource文件展开：

- **`SpawnEvent.gd` (Resource)**: 定义一个独立的生成事件（何时、生成谁、以何种方式、生成多少）。
- **`WaveResource.gd` (Resource)**: 定义一个完整的波次，其核心是一个按时间排序的 `SpawnEvent` 数组。

**3. 任务清单**

**3.1. 任务：[核心挑战] 开发“波次编辑器”插件**

- **描述**: 创建一个Godot编辑器插件。当用户在文件系统中双击一个`WaveResource`文件时，插件会提供一个专门的、基于时间轴的可视化编辑界面。
- **规格 (建议的实现步骤)**:
    1. **创建插件骨架**:
        - 在`addons/`文件夹下创建插件。
        - 编写一个继承自`EditorPlugin`的主脚本，并在`项目设置 -> 插件`中启用它。
    2. **识别并接管**:
        - 让插件能够识别用户何时选中或打开了`WaveResource`类型的资源。
    3. **构建UI界面**:
        - 设计一个自定义的UI场景（`Control`节点作为根）。
        - **时间轴**: 在UI中创建一个代表时间的横向标尺，其最大值与`WaveResource.duration`同步。
        - **事件可视化**: 读取`WaveResource`中的`events`数组，并将每一个`SpawnEvent`作为一个“事件块”绘制在时间轴的对应`trigger_time`位置上。
        - **事件编辑器**: 点击一个“事件块”后，在UI的某个区域（或使用默认的Inspector）显示该`SpawnEvent`的所有属性（敌人类型、数量等），并使其可被编辑。
    4. **实现交互功能**:
        - **拖拽**: 实现用鼠标拖动“事件块”来改变其`trigger_time`。
        - **增删**: 提供“创建新事件”和“删除选中事件”的按钮。
    5. **数据回写**: 确保在UI上做的所有修改（拖拽、修改属性）都能被正确地、实时地保存回对应的`.tres`资源文件中。
- **验收标准**: 设计师可以完全脱离默认的Inspector面板，通过这个可视化的时间轴编辑器，完成创建、编辑和保存一个完整的`WaveResource`文件的所有操作。
- **执行人**: 你自行尝试。

**3.2. 任务：实现“印记”场景**

- **描述**: 创建在敌人正式生成前，用于预警的“印记”场景。
- **规格**:
    - 场景包含一个视觉节点(`Sprite2D`/`AnimatedSprite2D`)，一个`Timer`节点，和一个用于检测玩家的`Area2D`节点。
    - 脚本需要能接收“最终要生成的敌人类型”作为参数。
    - 计时器结束后，检查`Area2D`内是否有玩家。如果有，则向主生成器发信号请求“重新定位”；如果没有，则在当前位置生成敌人。
- **产出**: `scenes/enemies/imprint.tscn`

**3.3. 任务：实现运行时生成器 (`EnemySpawner`)**

- **描述**: 创建负责在游戏运行时，读取`WaveResource`并执行生成逻辑的核心脚本。
- **规格**:
    1. **输入**: `EnemySpawner`能接收一个`WaveResource`作为当前波次的“剧本”。
    2. **计时**: 内部维护一个计时器，记录当前波次已进行的时间。
    3. **事件执行**: 实时检查计时器时间，一旦达到某个`SpawnEvent`的`trigger_time`，就立即执行该事件。
    4. **生成逻辑**: 执行事件时，调用我们之前确定的“安全圈”模型来选择生成位置，并在此位置实例化“印记”场景（任务3.2的产出）。
    5. **重新定位处理**: 能够接收并处理来自“印记”的“生成失败，请重新定位”的信号，并立即为该敌人重新执行生成流程。
- **验收标准**: 在游戏中，`EnemySpawner`能够精确地按照`WaveResource`文件（无论是手动创建的还是用新插件创建的）中定义的时间和规则，通过“印记”机制生成敌人。

### **模块四：武器与战斗循环 (Weapons & Combat Loop)**

**1. 目标**

构建一个模块化的、数据驱动的武器系统。该系统需支持玩家同时装备多把武器，实现武器的自动索敌与攻击，并通过“标签”与“套装奖励”系统提供丰富的策略深度。

**2. 核心架构：三层分离**

我们将采用“管理器 -> 武器实例 -> 攻击实例”的三层结构，确保各部分职责清晰，易于扩展。

**3. 任务清单**

**3.1. 任务：最终化 `WeaponResource` 数据结构**

- **描述**: 完善并最终确定用于定义所有武器静态数据的`WeaponResource`脚本。
- **规格**: 该`Resource`需包含以下核心字段：
    - **基础信息**: `weapon_name` (名称), `description` (描述), `icon` (图标)。
    - **核心数值**: `base_damage` (基础伤害), `base_cooldown` (基础攻击间隔)。
    - **攻击行为**: `attack_scene` (`PackedScene`类型), 指向该武器要实例化的“攻击实例”场景（如`bullet.tscn`）。
    - **策略深度**:
        - `tags` (`Array[String]`类型): 定义武器的标签，如["刀具", "近战"]。
        - `targeting_mode` (`Enum`类型): 定义索敌模式，默认值为`NEAREST` (最近的敌人)。

**3.2. 任务：实现玩家侧的“武器管理器” (`WeaponManager`)**

- **描述**: 在玩家场景中创建一个节点，作为所有武器的“司令部”，负责武器的装备和协同。
- **规格**:
    - **节点结构**: 在`Player.tscn`中添加一个`Node`，命名为`WeaponManager`。
    - **武器管理**:
        - 提供`add_weapon(weapon_resource)`函数。当被调用时，它会实例化一个“武器实例”（任务3.3）场景，将`weapon_resource`传递给它进行初始化，并将其作为自己的子节点。最多管理6个武器实例。
    - **套装奖励系统**:
        - `WeaponManager`的脚本需要实时（例如在每一帧）统计其所有子武器实例的`tags`。
        - 根据统计出的标签数量（如`{"刀具": 3}`），对照一个预设的“套装奖励规则”，计算出应给予玩家的属性加成。
        - 将计算出的奖励属性，直接施加给`Player`的属性系统。

**3.3. 任务：实现“武器实例” (`WeaponInstance`)**

- **描述**: 创建代表每一把“活的”、已装备武器的场景。它负责独立的攻击冷却和索敌。
- **规格**:
    - **场景结构**: 创建`WeaponInstance.tscn`，包含一个`Timer`节点用于攻击冷却。
    - **初始化**: 脚本在`_ready()`时接收一个`WeaponResource`，并据此设置基础信息。
    - **攻击循环**:
        1. `Timer`计时结束时，触发攻击流程。
        2. **获取属性**: 实时从`Player`身上读取最终的属性（如攻击速度、伤害加成）。
        3. **计算数值**: 根据玩家属性，计算出本次攻击的最终伤害和下一次攻击的冷却时间。
        4. **索敌**: 执行索敌逻辑（任务3.4），找到目标。
        5. **开火**: 如果找到目标，则实例化并配置“攻击实例”（任务3.5）。
        6. **重启计时器**: 使用计算出的最终冷却时间，重新启动`Timer`。

**3.4. 任务：实现索敌逻辑 (Targeting Logic)**

- **描述**: 为武器实例提供寻找目标的能力。
- **规格**:
    - **默认逻辑**: 实现“寻找最近的敌人”的逻辑。这可以通过在玩家身上挂载一个大范围的`Area2D`来实时追踪进入范围的敌人，然后在需要时遍历这个列表计算距离得出最近者。
    - **扩展性**: 武器实例的索敌函数应能根据`WeaponResource`中定义的`targeting_mode`，切换不同的索敌行为（此为后期扩展项）。

**3.5. 任务：实现“攻击实例” (`AttackInstance`)**

- **描述**: 创建实际造成伤害的、短暂存在的场景，如子弹、刀光等。
- **规格**:
    - **场景结构**: 创建多个`AttackInstance`场景（如`bullet.tscn`, `sword_swipe.tscn`），核心是一个带有`CollisionShape2D`的`Area2D`。
    - **初始化**: 脚本能接收来自`WeaponInstance`的参数，如最终伤害值。
    - **攻击方仲裁**:
        - 脚本内部必须包含一个`hit_list`数组，用于记录本实例已经命中过的敌人。
        - 当`Area2D`检测到敌人时，先查询`hit_list`。
        - **如果敌人不在列表中**: 将其加入列表，并对该敌人调用`take_damage`函数。
        - **如果敌人已在列表中**: 忽略该敌人。
    - **生命周期**: 攻击实例在完成其使命后（如命中敌人、飞出屏幕、持续时间结束），必须自我销毁 (`queue_free()`)。

**4. 验收标准**

- 玩家可以正常装备最多6把武器，并能看到武器在场景中（如果武器有实体）。
- 所有武器都能根据玩家的实时属性（尤其是攻击速度），以正确的频率自动攻击最近的敌人。
- 一次攻击行为（如一次挥砍、一次霰弹枪射击）对同一个敌人只会造成一次伤害。
- 套装奖励系统正常运作：当玩家凑齐特定标签组合的武器时，其角色面板的对应属性有正确的提升。

### **模块五：成长与奖励循环 (Progression & Reward Loop)**

**1. 目标**

构建驱动玩家在单局游戏内循环变强的核心系统。该系统的核心是，玩家通过击杀敌人获得统一的战利品“材料”，并将其转化为“经验”和“金钱”，分别用于角色升级和商店消费，形成一个完整的成长闭环。

**2. 任务清单**

**2.1. 任务：创建战利品场景 (`Loot Scenes`)**

- **描述**: 创建代表可拾取战利品的独立场景。
- **规格**:
    - **`material.tscn` (材料)**:
        - 这是最核心的掉落物。
        - 场景需包含 `Area2D` (用于检测拾取)、`Sprite2D` (视觉)。
        - 脚本需包含可配置的变量：`xp_value` (蕴含的经验值) 和 `money_value` (蕴含的金钱)。
    - **`consumable.tscn` (消耗品)**:
        - 这是概率性掉落物（如回血果）。
        - 场景结构与材料类似。
        - 脚本需定义其被拾取时触发的一次性效果（例如，`heal_amount`）。

**2.2. 任务：实现敌人掉落逻辑 (`Enemy Drop Logic`)**

- **描述**: 在敌人死亡时，根据规则生成对应的战利品。
- **规格**:
    - **监听死亡事件**: 在敌人的脚本或其`HealthComponent`中，监听`died`信号。
    - **材料掉落**: 当敌人死亡时，高概率（或100%）在原地实例化`material.tscn`。掉落材料的`xp_value`和`money_value`可由该敌人类型决定。
    - **消耗品掉落**: 在敌人死亡时，**独立地**进行一次概率判定。该概率受玩家的`Luck`属性动态影响（公式待研究）。判定成功，则在原地额外实例化`consumable.tscn`。

**2.3. 任务：实现玩家拾取机制 (`Player Collection System`)**

- **描述**: 为玩家赋予拾取战利品的能力，并包含核心的“吸附”体验。
- **规格**:
    - **节点结构**: 在`Player.tscn`场景中添加两个`Area2D`子节点。
        - **拾取区 (Pickup Area)**: 较小的范围，用于和掉落物直接碰撞时触发拾取。
        - **吸附区 (Attraction Area)**: 较大的范围。
    - **吸附逻辑**: 进入“吸附区”的战利品，会受到一个持续朝向玩家中心移动的力，形成自动吸附效果。该区域的半径可以作为一个可升级的属性。
    - **转化逻辑**: 当“拾取区”接触到战利品时：
        - 如果是**材料**: 增加玩家的`current_xp`和`current_money`，然后销毁该材料实例。
        - 如果是**消耗品**: 触发其一次性效果（如回血），然后销毁该消耗品实例。

**2.4. 任务：实现经验与升级系统 (`Level-Up System`)**

- **描述**: 管理玩家的经验增长、升级事件以及奖励选择。
- **规格**:
    - **数值管理**: `Player`脚本负责管理`current_xp`和`xp_to_next_level`。
    - **升级事件**: 当`current_xp`满足升级条件时，触发升级流程。此流程应暂停游戏的核心玩法。
    - **奖励UI**: 弹出一个UI界面，提供3-4个随机的属性升级选项。
    - **奖励池**: 这些选项从一个全局的“升级奖励池”中随机抽取。
    - **[待研究项]**: 具体的奖励池刷新机制、是否会排除已选过的高级选项等，需要通过查阅Wiki或在游戏中测试来精确复现。

**2.5. 任务：实现商店系统 (`Shop System`)**

- **描述**: 在每波战斗结束后，呈现一个功能完备的商店，供玩家消费“金钱”。
- **规格**:
    - **触发时机**: 在一波结束后（敌人全部清空），暂停游戏并显示商店UI。
    - **核心功能**:
        - **商品槽**: 提供4个商品槽位。
        - **购买**: 玩家可以花费金钱购买槽位中的武器或道具。
        - **刷新 (Reroll)**: 玩家可以花费金钱（费用会递增）刷新所有未锁定的商品。
        - **锁定 (Lock)**: 玩家可以锁定某个商品，使其在下次刷新时保留。
    - **商品生成逻辑**:
        - 商品从一个巨大的“总商品池”中随机抽取。
        - **[待研究项]**: 抽取的概率，特别是物品的**稀有度**，受到**玩家等级、当前波数以及“幸运(`Luck`)”属性**的复杂影响。需要对Brotato Wiki进行深入研究，以尽可能精确地复现其概率公式。

**3. 验收标准**

- 敌人死亡后能正确掉落“材料”，并根据玩家“幸运”属性概率性掉落“消耗品”。
- 玩家靠近掉落物时有明显的吸附效果，拾取“材料”后，经验值和金钱同时增加。
- 经验条满后，游戏会暂停并提供随机的升级选项，选择后玩家属性会正确提升。
- 波次结束后，商店正常出现，并能提供随机商品。
- 商店的购买、锁定、刷新功能运作正常，且玩家购买的物品能正确地增强其在下一波战斗中的能力。

### **模块六及以后：后期拓展与产品化 (Consolidated Post-Core Modules)**

**1. 目标**

在完成核心玩法循环的原型后，围绕这个核心，逐步增加长期可玩性内容，并将其打磨成一个完整的游戏产品。

**2. 任务清单 (高阶规划)**

此阶段的任务将在核心原型得到验证和测试后，再进行详细的分解。当前阶段，我们只确立其核心工作方向。

- **2.1. 局外成长与解锁系统 (Meta-Progression)**
    - **方向**: 设计并实现一个基于“成就/里程碑”的永久性解锁系统，用于解锁新的角色、武器、道具，以增强游戏的重玩价值。
- **2.2. 内容填充与创新实现 (Content & Innovation)**
    - **方向**:
        - 根据确立的世界观，大规模填充武器、道具和角色的数据。
        - 实现我们规划的创新点，特别是拥有独特机制的**BOSS战**。
- **2.3. 游戏“外壳”与流程管理 (UI & Game Flow)**
    - **方向**: 开发功能性的主菜单、角色选择、设置、结算等界面，并建立一个稳定的状态机来管理整体游戏流程。
- **2.4. 感官体验打磨 (Polish & Juice)**
    - **方向**:
        - 根据确立的世界观，统一设计并实现游戏的美术风格和音效。
        - 集成我们之前讨论的“通用感官打磨”方案（屏幕震动、命中停顿、粒子效果等），全面提升游戏的“爽快感”。
        - 进行性能优化，确保游戏后期体验流畅。